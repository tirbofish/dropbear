use crate::ScriptManifest;
use crate::generator::Generator;
use chrono::Utc;
use std::collections::HashMap;
use std::fmt::Write;

pub struct KotlinNativeGenerator;

impl Generator for KotlinNativeGenerator {
    fn generate(&self, manifest: &ScriptManifest) -> anyhow::Result<String> {
        let mut output = String::new();
        let local_time = Utc::now();
        writeln!(
            output,
            "// Auto-generated by dropbear-engine with the magna-carta parser on {} UTC",
            local_time.format("%Y-%m-%d %H:%M:%S")
        )?;
        writeln!(
            output,
            "@file:OptIn(ExperimentalForeignApi::class, ExperimentalNativeApi::class)"
        )?;
        writeln!(output, "@file:Suppress(\"UNUSED_PARAMETER\", \"unused\")")?;
        writeln!(output)?;

        writeln!(output, "package com.dropbear.decl")?;
        writeln!(output)?;

        writeln!(
            output,
            r#"import com.dropbear.DropbearEngine
import com.dropbear.System
import com.dropbear.ffi.NativeEngine
import com.dropbear.ffi.generated.DropbearContext
import com.dropbear.logging.Logger
import kotlinx.cinterop.*
import kotlin.experimental.ExperimentalNativeApi"#
        )?;
        writeln!(output)?;

        let mut imported_classes = Vec::new();
        for item in manifest.items() {
            if let Some(last_dot) = item.fqcn().rfind('.') {
                let package = &item.fqcn()[..last_dot];
                let simple_name = &item.fqcn()[last_dot + 1..];
                writeln!(output, "import {}.{}", package, simple_name)?;
                imported_classes.push(simple_name.to_string());
            } else {
                imported_classes.push(item.simple_name().to_string());
            }
        }
        writeln!(output)?;

        let mut tag_map: HashMap<String, Vec<String>> = HashMap::new();
        for item in manifest.items() {
            let simple_name = item.simple_name();
            if item.tags().is_empty() {
                continue;
            }
            for tag in item.tags() {
                tag_map
                    .entry(tag.clone())
                    .or_default()
                    .push(simple_name.to_string());
            }
        }

        writeln!(
            output,
            r#"
object ScriptManager {{
    private var nativeEngine: NativeEngine? = null
    private var dropbearEngine: DropbearEngine? = null
    private val scriptsByTag: MutableMap<String, MutableList<System>> = mutableMapOf()

    fun init(dropbearContextPtr: CPointer<DropbearContext>?) : Int {{
        try {{
            val ctx = dropbearContextPtr?.pointed

            val engine = nativeEngine ?: NativeEngine().also {{ nativeEngine = it }}
            engine.init(ctx)

            if (dropbearEngine == null) {{
                dropbearEngine = DropbearEngine(engine)
            }}

            Logger.debug("Native ScriptManager initialised")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Native ScriptManager failed to initialise: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun loadSystemsByTag(tag: String): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            if (scriptsByTag.containsKey(tag)) {{
                Logger.trace("Systems already loaded for tag: '$tag'")
                val instances = scriptsByTag[tag] ?: emptyList()
                for (instance in instances) {{
                    instance.attachEngine(engine)
                    instance.load(engine)
                }}
                return 0
            }}
            val factories = getScriptFactories(tag)
            val instances = factories.map {{ it() }}

            for (instance in instances) {{
                instance.attachEngine(engine)
                instance.load(engine)
            }}

            scriptsByTag.getOrPut(tag) {{ mutableListOf() }}.addAll(instances)
            Logger.debug("Loaded ${{instances.size}} script(s) for tag: '$tag'")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error loading systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun updateAllSystems(dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            for (instances in scriptsByTag.values) {{
                for (instance in instances) {{
                    instance.attachEngine(engine)
                    instance.clearCurrentEntity()
                    instance.update(engine, dt)
                }}
            }}
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error updating all systems: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun updateSystemsByTag(tag: String, dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.attachEngine(engine)
                instance.clearCurrentEntity()
                instance.update(engine, dt)
            }}
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error updating systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun physicsUpdateAllSystems(dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            for (instances in scriptsByTag.values) {{
                for (instance in instances) {{
                    instance.attachEngine(engine)
                    instance.clearCurrentEntity()
                    instance.physicsUpdate(engine, dt)
                }}
            }}
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error physics updating all systems: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun physicsUpdateSystemsByTag(tag: String, dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.attachEngine(engine)
                instance.clearCurrentEntity()
                instance.physicsUpdate(engine, dt)
            }}
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error physics updating systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun updateSystemsForEntities(tag: String, entities: CPointer<ULongVar>, entityCount: Int, dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val instances = scriptsByTag[tag] ?: emptyList()

            val entityIds = LongArray(entityCount) {{ index ->
                entities[index].toLong()
            }}

            Logger.trace("Updating systems for tag: $tag with $entityCount entities")

            if (instances.isEmpty()) {{
                return 0
            }}

            if (entityIds.isEmpty()) {{
                for (instance in instances) {{
                    instance.update(engine, dt)
                }}
                return 0
            }}

            for (entityId in entityIds) {{
                for (instance in instances) {{
                    try {{
                        instance.attachEngine(engine)
                        instance.setCurrentEntity(entityId)
                        instance.update(engine, dt)
                    }} catch (ex: Exception) {{
                        Logger.error("Failed to update system $instance for entity $entityId: ${{ex.message}}")
                    }}
                }}
            }}

            for (instance in instances) {{
                instance.clearCurrentEntity()
            }}

            Logger.debug("Updated ${{instances.size}} system(s) for tag '$tag' with ${{entityCount}} entities")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error updating systems for tag '$tag' with entities: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun physicsUpdateSystemsForEntities(tag: String, entities: CPointer<ULongVar>, entityCount: Int, dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val instances = scriptsByTag[tag] ?: emptyList()

            val entityIds = LongArray(entityCount) {{ index ->
                entities[index].toLong()
            }}

            Logger.trace("Physics updating systems for tag: $tag with $entityCount entities")

            if (instances.isEmpty()) {{
                return 0
            }}

            if (entityIds.isEmpty()) {{
                for (instance in instances) {{
                    instance.physicsUpdate(engine, dt)
                }}
                return 0
            }}

            for (entityId in entityIds) {{
                for (instance in instances) {{
                    try {{
                        instance.attachEngine(engine)
                        instance.setCurrentEntity(entityId)
                        instance.physicsUpdate(engine, dt)
                    }} catch (ex: Exception) {{
                        Logger.error("Failed to physics update system $instance for entity $entityId: ${{ex.message}}")
                    }}
                }}
            }}

            for (instance in instances) {{
                instance.clearCurrentEntity()
            }}

            Logger.debug("Physics updated ${{instances.size}} system(s) for tag '$tag' with ${{entityCount}} entities")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error physics updating systems for tag '$tag' with entities: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun destroyByTag(tag: String): Int {{
        try {{
            val engine = dropbearEngine ?: return -2
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.destroy(engine)
            }}
            scriptsByTag.remove(tag)
            Logger.debug("Destroyed ${{instances.size}} script(s) for tag: '$tag'")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error destroying systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun destroyInScopeByTag(tag: String): Int {{
        try {{
            val engine = dropbearEngine ?: return -2
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.destroy(engine)
            }}
            Logger.debug("Destroyed (in-scope) ${{instances.size}} script(s) for tag: '$tag'")
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error destroying (in-scope) systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun destroyAll(): Int {{
        try {{
            val engine = dropbearEngine ?: return -2
            for (instances in scriptsByTag.values) {{
                for (instance in instances) {{
                    instance.destroy(engine)
                }}
            }}
            scriptsByTag.clear()
            dropbearEngine = null
            nativeEngine = null
            return 0
        }} catch (e: Exception) {{
            dropbear_set_last_error("Error destroying scripts: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}
            "#
        )?;

        // getScriptFactories (generated)
        {
            writeln!(
                output,
                "\
    private fun getScriptFactories(tag: String): List<() -> System> {{"
            )?;
            writeln!(output, "       return when (tag) {{")?;

            for (tag, classes) in &tag_map {
                let factories: Vec<String> = classes
                    .iter()
                    .map(|cls| format!("{{ {}() }}", cls))
                    .collect();
                writeln!(
                    output,
                    "           \"{}\" -> listOf({})",
                    tag,
                    factories.join(", ")
                )?;
            }

            writeln!(output, "           else -> emptyList()")?;
            writeln!(output, "        }}")?;
            writeln!(output, "    }}")?;
            writeln!(output)?;
        }

        writeln!(output, "}}")?;

        // ADD CNAME FUNCTIONS HERE
        writeln!(
            output,
            r#"
fun CPointer<ULongVar>.toLongArray(length: Int): LongArray {{
    require(length >= 0) {{ "Length must be non-negative" }}
    return LongArray(length) {{ index ->
        this[index].toLong()
    }}
}}

@CName("dropbear_init")
fun dropbear_native_init(dropbearContextPtr: CPointer<DropbearContext>?): Int {{
    return ScriptManager.init(dropbearContextPtr)
}}

@CName("dropbear_load_tagged")
fun dropbear_load_systems_for_tag(tag: String?): Int {{
    if (tag == null) return -1
    return ScriptManager.loadSystemsByTag(tag)
}}

@CName("dropbear_update_all")
fun dropbear_update_all_systems(dt: Float): Int {{
    return ScriptManager.updateAllSystems(dt)
}}

@CName("dropbear_update_tagged")
fun dropbear_update_systems_for_tag(tag: String?, dt: Float): Int {{
    if (tag == null) return -1
    return ScriptManager.updateSystemsByTag(tag, dt)
}}

@CName("dropbear_update_with_entities")
fun dropbear_update_systems_for_entities(tag: String?, entities: CPointer<ULongVar>?, entityCount: Int, dt: Float): Int {{
    if (tag == null || entities == null) return -1
    return ScriptManager.updateSystemsForEntities(tag, entities, entityCount, dt)
}}

@CName("dropbear_physics_update_all")
fun dropbear_physics_update_all_systems(dt: Float): Int {{
    return ScriptManager.physicsUpdateAllSystems(dt)
}}

@CName("dropbear_physics_update_tagged")
fun dropbear_physics_update_systems_for_tag(tag: String?, dt: Float): Int {{
    if (tag == null) return -1
    return ScriptManager.physicsUpdateSystemsByTag(tag, dt)
}}

@CName("dropbear_physics_update_with_entities")
fun dropbear_physics_update_systems_for_entities(tag: String?, entities: CPointer<ULongVar>?, entityCount: Int, dt: Float): Int {{
    if (tag == null || entities == null) return -1
    return ScriptManager.physicsUpdateSystemsForEntities(tag, entities, entityCount, dt)
}}

@CName("dropbear_destroy_tagged")
fun dropbear_destroy(tag: String?): Int {{
    if (tag == null) return -1
    return ScriptManager.destroyByTag(tag)
}}

@CName("dropbear_destroy_in_scope_tagged")
fun dropbear_destroy_in_scope(tag: String?): Int {{
    if (tag == null) return -1
    return ScriptManager.destroyInScopeByTag(tag)
}}

@CName("dropbear_destroy_all")
fun dropbear_destroy_all(): Int {{
    return ScriptManager.destroyAll()
}}

@CName("dropbear_get_last_error")
fun dropbear_get_last_error(): String? {{
    return com.dropbear.lastErrorMessage
}}

@CName("dropbear_set_last_error")
fun dropbear_set_last_error(err: String?) {{
    com.dropbear.lastErrorMessage = err
}}
        "#
        )?;

        Ok(output)
    }
}